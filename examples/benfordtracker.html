<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>tracking.js - color with video</title>

  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <!--<link rel="stylesheet" href="assets/demo.css">
  <script src="../node_modules/dat.gui/build/dat.gui.min.js"></script>
  <script src="assets/stats.min.js"></script>
  <script src="assets/color_camera_gui.js"></script>-->
  <script src="../build/tracking-min.js"></script>
  <style>
  .demo-container {
    background-color: black;
  }

  video, canvas {
    position: absolute;
  }
  </style>
</style>
</head>
<body>
  <h2>Teste Algorítimo Benford</h2>
  <table width="1200" vertical-align="top">
    <tbody>
      <tr>
        <td>
          <div class="inputoutput">
            <div class="caption">
              <button type="button" id="buttonCameraVideo">Usar câmera</button>
              ou Selecione um vídeo. <input type="file" id="fileInputVideo" name="file" />
              <!--
              <input id="slider" oninput="mudarVolume(0)" type="range" min="0" max="10" value="0" step="0.01">
              Volume: <span id="volume"></span>
            -->
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <div class="demo-frame">
          <div class="demo-container">
            <video id="myVideo" width="800" height="500" preload autoplay loop muted></video>
            <canvas id="canvas" width="800" height="500"></canvas>
          </div>
        </div>
      </td>
      <td>
        <div id="triplo" style="width: 300px; height: 500px;"></div>
        <!--<div id="espacial" style="width: 300px; height: 500px;"></div>-->
        <!--<div id="temporal" style="width: 300px; height: 500px;"></div>-->
      </td>
    </tr>
  </tbody>
</table>

<script>
// Implementação de Benford Tracker -----------------------------------------------------------
// Quantidade de frames a serem contabilizados para os gradientes acumuldos
var quantidadeFramesAmostra = 10;
// Váriável que armazena a lista de valores padrões de benford
var valoresBenford = [9];
// Indice da fila que controla qual item da fila está sendo inserido para cada frame processado
var indiceFila = 0;
/* Variáveis que armazenam acorrencia de valores de primeiro dídigo para cada frame processado,
os acumulados temporais fundem dados de dois frames, por isso são menores que o espacial*/
var ocorrenciaEspacialPorFrame = [quantidadeFramesAmostra-1];
var ocorrenciaTriploPorFrame = [quantidadeFramesAmostra-1];
var ocorrenciaTemporalPorFrame = [quantidadeFramesAmostra-1];
// Variável armazena o frame anterior para comparar com o atual
var frameAnterior = null;
/*Variável identifica quando a fila de frames processados enche pela primeira vez, a partir
desse momento o algoritimo  deve substituir indices já existentes da fila*/
var  filaCheia = false;
// Variável para armazenar os resultados
var results = null;

//Inicização dos valores padrões de Benford
valoresBenford[0] = Math.log10(1.0+1.0/1.0);
valoresBenford[1] = Math.log10(1.0+1.0/2.0);
valoresBenford[2] = Math.log10(1.0+1.0/3.0);
valoresBenford[3] = Math.log10(1.0+1.0/4.0);
valoresBenford[4] = Math.log10(1.0+1.0/5.0);
valoresBenford[5] = Math.log10(1.0+1.0/6.0);
valoresBenford[6] = Math.log10(1.0+1.0/7.0);
valoresBenford[7] = Math.log10(1.0+1.0/8.0);
valoresBenford[8] = Math.log10(1.0+1.0/9.0);

// Classe principal do augorítimo de processamento de frame com base em Benford.
function BenfordTracker() {

/*Função principal do processamento. Essa função vai ser chamada para processar cada pixel, dessa forma
é necessário criar estratégias de otimização para que não acumulasse volume muito grande de dados.
Responsável por sobrescrever a função track da api tracking.js
permitindo receber uma matriz de pixels RGB em formato de array, a largura e autura da imgagem
representada na matriz.*/
  this.track = function(pixels, width, height) {
    /* usamos uma função interna da api para transformar a matriz de pixel RGB recebida em uma matriz cinza ]
    esse processo basicamente torna a matriz 3 vezes menor e diminui a complexidade dos calculos*/
    let gray = tracking.Image.grayscale(pixels, width, height, false);
    // Essa função zera a fila de ocorrencia permitindo o reuso das variáveis para otimizar o código
    zerarFilaOcorrencia();
    // Essa função processa o frame de pixels em escala de cinza e arrmazena nas variáveis da fila de ocorrencias
    processarFrame(gray, width, height);
    /* Essa função calcula a ocorrencia acumulada e outros dados de cada numero na fila de ocorrencia e armzena
    tudo em um mapa de resultados  */
    results = calcularOcorrencia();

    //Essa é uma chamada da API que envia os resultados para o métodos que estão ouvindo a API
    this.emit('track', {
      data: results
    });
  }

// Essa função zera a fila de ocorrencia permitindo o reuso das variáveis para otimizar o código
  function zerarFilaOcorrencia(){
    //Percorre a fila de ocorrencia
    for(let x = 0; x < quantidadeFramesAmostra-1; ++x) {
      //Inicializa um array para cada numero de 1 a 9
      ocorrenciaTriploPorFrame[x] = [9];
      ocorrenciaTemporalPorFrame[x] = [9];
      ocorrenciaEspacialPorFrame[x] = [9];
      //Inicializa todas as ocorrencias com 0.0
      for(let y = 0; y < quantidadeFramesAmostra; ++y) {
        ocorrenciaEspacialPorFrame[x][y] = 0.0;
        ocorrenciaTemporalPorFrame[x][y] = 0.0;
        ocorrenciaTriploPorFrame[x][y] = 0.0;
      }
    }
  };

/**
// Essa função processa o frame de pixels em escala de cinza e arrmazena nas variáveis da fila de ocorrencias
TODO:Criar classe ProcessadorFrame posteriormente*/
  function processarFrame( frame, width, height ) {
    //Inicializa uma variável para calcular cada gradiente
    let gradienteEspacial = 0;
    let gradienteTemporal = 0;
    let gradienteTriplo = 0;

    /* Para processar o primeiro frame é necessário existir frame anterior pois as análises temporais usam frame frameAnterior,
    portanto não procesa o primeiro frame, apenas a partir do segundo
    TODO Verificar se o não processamento do gradiente temporal do primeiro frame prejudica o algorítimo, até onde olhei não
    pois no código original também se pulava o primeiro frame*/
    if(frame && frameAnterior){
      /*Para calcular os gradientes fazemos uso de alguns cálculos que foram divididos em partes aqui para que os valores fossem
      reusados. no caso dos qaudrado temporal e espacial são usados para armazenar uma potencia de 2*/
      let quadradoTemporal = 0;
      let quadradoEspacialHorizontal = 0;
      //Essa variavel armazena a ocorrencia do primeiro dígido na análise pixel a pixel
      let contaOcorrenciaNumeroPrimeiroDigito = 0 ;
      /*Usamos o index para percorrer todos os pixels da imagem exceto o primeiro e a última coluna por conta do gradiente espacial que usa o
      primeiro pixel como peixel anterior e não tem com quem comparar a última coluna
      TODO Vericicar se realmente não se deve percorrer a última colua, apesar de estar igual ao algoritimo original*/
      for (var index = 1; index < height*width-width; ++index) {
        //
        gradienteTemporal = frame[index] - frameAnterior[index];
        let gradienteEspacialHorizontal = frame[index+1] - frame[index];
        let gradienteEspacialVertical = frame[index+width] - frame[index];
        quadradoTemporal = Math.pow(gradienteTemporal, 2);
        gradienteEspacial = Math.sqrt(Math.pow(gradienteEspacialHorizontal, 2)  + Math.pow(gradienteEspacialVertical, 2));
        gradienteTriplo = Math.sqrt( gradienteEspacial + quadradoTemporal);


        if (gradienteEspacial > 0.001) {//se a norma espacial for significativa conta o primeiro digito encontrado
          if(gradienteEspacial > 100) {
            contaOcorrenciaNumeroPrimeiroDigito = (gradienteEspacial-gradienteEspacial%100)/100;
          } else if (gradienteEspacial > 10) {
            contaOcorrenciaNumeroPrimeiroDigito = (gradienteEspacial-gradienteEspacial%10)/10;
          } else {
            contaOcorrenciaNumeroPrimeiroDigito = gradienteEspacial-gradienteEspacial%1;
          }//crescenta +1 na ocorrencia do número no frame
          ocorrenciaEspacialPorFrame[indiceFila][contaOcorrenciaNumeroPrimeiroDigito-1]++;
        }

        if (gradienteTemporal > 0.001) {//se a norma espacial for significativa
          if(gradienteTemporal > 100) {
            contaOcorrenciaNumeroPrimeiroDigito = (gradienteTemporal-gradienteTemporal%100)/100;
          } else if (gradienteTemporal > 10) {
            contaOcorrenciaNumeroPrimeiroDigito = (gradienteTemporal-gradienteTemporal%10)/10;
          } else {
            contaOcorrenciaNumeroPrimeiroDigito = gradienteTemporal-gradienteTemporal%1;
          }
          ocorrenciaTemporalPorFrame[indiceFila][contaOcorrenciaNumeroPrimeiroDigito-1]++;
        }

        if (gradienteTriplo > 0.001) {//se a norma espacial for significativa
          if(gradienteTriplo > 100) {
            contaOcorrenciaNumeroPrimeiroDigito = (gradienteTriplo-gradienteTriplo%100)/100;
          } else if (gradienteTemporal > 10) {
            contaOcorrenciaNumeroPrimeiroDigito = (gradienteTriplo-gradienteTriplo%10)/10;
          } else {
            contaOcorrenciaNumeroPrimeiroDigito = gradienteTriplo-gradienteTriplo%1;
          }
          ocorrenciaTriploPorFrame[indiceFila][contaOcorrenciaNumeroPrimeiroDigito-1]++;
        }
      }
      if(!filaCheia && (indiceFila >= quantidadeFramesAmostra-2)){
        filaCheia = true;
      }
      indiceFila++;
      indiceFila = indiceFila%(quantidadeFramesAmostra-1);

    } else {
      //Caso não exista frame anterior, pulamos o primeiro frame e tornamos ele o frame anterior
      frameAnterior = frame;
      frame = null;
    }
  };

  diferencaTripla = 0.0;
  diferencaEspacial = 0.0;
  diferencaTemporal = 0.0;

  function calcularOcorrencia(){
    if(filaCheia){
      let acumuladoTriplo = 0;
      let acumuladoEspacial = 0;
      let acumuladoTemporal = 0;
      let acumuladoTriploPorNumero = [9];
      let acumuladoEspacialPorNumero = [9];
      let acumuladoTemporalPorNumero = [9];

      for(let x = 0; x < quantidadeFramesAmostra-1; ++x) {
        for(let y = 0; y < 9; ++y) {
          if(ocorrenciaEspacialPorFrame[x][y]){
            acumuladoEspacial += ocorrenciaEspacialPorFrame[x][y];
            acumuladoEspacialPorNumero[y] += ocorrenciaEspacialPorFrame[x][y];
          }
          if(ocorrenciaTemporalPorFrame[x][y]){
            acumuladoTemporal += ocorrenciaTemporalPorFrame[x][y];
            acumuladoTemporalPorNumero[y] += ocorrenciaTemporalPorFrame[x][y];
          }
          if(ocorrenciaTriploPorFrame[x][y]){
            acumuladoTriplo += ocorrenciaTriploPorFrame[x][y];
            acumuladoTriploPorNumero[y] += ocorrenciaTriploPorFrame[x][y];
          }
        }
      }

      for(let nivel = 0; nivel < 9; nivel++) {
        if (acumuladoEspacialPorNumero[nivel]){
            if (((acumuladoEspacialPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel]) > 0) {
              diferencaTripla += ((acumuladoEspacialPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel]);
            } else {
              diferencaTripla -= ((acumuladoEspacialPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel]);
            }
        }
      }
      diferencaTripla /= 2;
      diferencaTripla = 1 - diferencaTripla;

      for(let nivel = 0; nivel < quantidadeFramesAmostra; nivel++) {
          if (acumuladoTriploPorNumero[nivel]){
            if (((acumuladoTriploPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel]) > 0) {
              diferencaEspacial += ((acumuladoTriploPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel]);
            } else {
              diferencaEspacial -= ((acumuladoTriploPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel]);
            }
          }
      }
      diferencaEspacial /= 2;
      diferencaEspacial = 1 - diferencaEspacial;

      for(let nivel = 0; nivel < 9; nivel++) {
          if (acumuladoTemporalPorNumero[nivel]){
            if (((acumuladoTemporalPorNumero[nivel]/acumuladoTemporal)-valoresBenford[nivel]) > 0) {
              diferencaTemporal += ((acumuladoTemporalPorNumero[nivel]/acumuladoTemporal)-valoresBenford[nivel]);
            } else {
              diferencaTemporal -= ((acumuladoTemporalPorNumero[nivel]/acumuladoTemporal)-valoresBenford[nivel]);
            }
          }
      }
      diferencaTemporal /= 2;
      diferencaTemporal = 1 - diferencaTemporal;

      let mapaOcorrencia = new Map();
      mapaOcorrencia.set("direfencaEspacial", diferencaEspacial.toFixed(2));
      mapaOcorrencia.set("diferencaTemporal", diferencaTemporal.toFixed(2));
      mapaOcorrencia.set("diferencaTriplo", diferencaTripla.toFixed(2));
      mapaOcorrencia.set("espacialPorFrame", ocorrenciaEspacialPorFrame);
      mapaOcorrencia.set("temporalPorFrame", ocorrenciaTemporalPorFrame);
      mapaOcorrencia.set("triploPorFrame", ocorrenciaTriploPorFrame);
      mapaOcorrencia.set("acumuladoEspacial", acumuladoEspacial);
      mapaOcorrencia.set("acumuladotemporal", acumuladoTemporal);
      mapaOcorrencia.set("acumuladotriplo", acumuladoTriplo);
      mapaOcorrencia.set("acumuladoEspacialPorNumero", acumuladoEspacialPorNumero);
      mapaOcorrencia.set("acumuladotemporalPorNumero", acumuladoTemporalPorNumero);
      mapaOcorrencia.set("acumuladotriploPorNumero", acumuladoTriploPorNumero);
      return mapaOcorrencia;
    }
  }

}


// Load the Visualization API and the corechart package.
google.charts.load('current', {'packages':['bar']});
// Set a callback to run when the Google Visualization API is loaded.
google.charts.setOnLoadCallback(drawStuff);
// Callback that creates and populates a data table,
// instantiates the pie chart, passes in the data and
// draws it.
var chart = null;
var data = null;

function loadDataChart(){
  let resultado =  0;
  if(results){
    resultado = results.get("diferencaTriplo");
    resultado *= 100;
  }
  if(data){
    if(data.getNumberOfRows()>0){
      data.removeRows(0,1);
    }
    data.addRow([resultado,resultado]);
  } else {
    data = new google.visualization.DataTable();
    data.addColumn('number', 'Difereça Tripla');
    data.addColumn('number', 'Difereça Tripla');
  }
}

function drawStuff() {
  // Create the data table.
  loadDataChart();
  // Set chart options
  var options = {
    title: 'Gradiente Triplo de Benford',
    width: 300,
    legend: { position: 'none' },
    chart: { title: 'Gradiente Triplo de Benford',
    subtitle: 'Ocorrencia primeiro dígito por número' },
    bars: 'vertical', // Required for Material Bar Charts.
    axes: {
      x: {
        0: { side: 'down', label: 'Números'} // Top x-axis.
      },
      y: {
        0: { side: 'left', label: 'Porcentágem'} // Top x-axis.
      }
    },
    bar: { groupWidth: "90%" }
  };
  // Instantiate and draw our chart, passing in some options.
  chart = new google.charts.Bar(document.getElementById('triplo'));
  chart.draw(data, options);
};

window.setInterval('drawStuff()', 1000);
//Implementação da Herança de BenfordTracker em relação a Traker da API tracking.js
tracking.inherits(BenfordTracker, tracking.Tracker);;
BenfordTracker.prototype.constructor = BenfordTracker;

var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');

var myTracker = new BenfordTracker();

//Tratamento de eventos recebidos já processados
myTracker.on('track', function(event){
  context.clearRect(0, 0, canvas.width, canvas.height);
  context.strokeStyle = "#000";
  context.font = '10px Helvetica';
  context.fillStyle = "#000"

  if(event.data){

    //mudarVolume(event.data.get("diferencaTriplo"));
    mudarFrequencia(event.data.get("diferencaTriplo"));
    context.fillText("Espacial: " + event.data.get("direfencaEspacial"), 0 + 5, 10 + 22);
    context.fillText("Temporal: " + event.data.get("diferencaTemporal"), 0 + 5, 20 + 22);
    context.fillText("Triplo: " + event.data.get("diferencaTriplo"), 0 + 5, 30 + 22);
  }
});

// Controes de Entrada --------------------------------------------------------
//Exibir e processar o video da câmera  function capturaVideoWebCam
let inputElementVideo1 = document.getElementById('buttonCameraVideo');
inputElementVideo1.addEventListener('click', (e) => {
  tracking.track('#myVideo', myTracker, { camera: true });
  playSound();
}, false);
//Exibir e processar video do armazenamento local
let inputElementVideo2 = document.getElementById('fileInputVideo');
inputElementVideo2.addEventListener('change', (e) => {
  let videoTag = document.getElementById('myVideo');
  videoTag.src=URL.createObjectURL(e.target.files[0]);
  videoTag.play();
  tracking.track('#myVideo', myTracker);
  playSound();
}, false);
// -------------------------------------------------------- Controes de Entrada

// Controles de Som -----------------------------------------------------------
var audioContext = new (window.AudioContext || window.webkitAudioContext)();
var isPlaing = false;

var real = new Float32Array(2);
var imag = new Float32Array(2);

real[0] = 0;
imag[0] = 0;
real[1] = 1;
imag[1] = 0;
let tipo = 'sine';
var osciladors = [5]
osciladors[0] = audioContext.createOscillator();
osciladors[0].frequency.setValueAtTime(220, audioContext.currentTime);
//osciladors[0].type = 'square';
osciladors[0].type = tipo;
osciladors[1] = audioContext.createOscillator();
osciladors[1].frequency.setValueAtTime(176, audioContext.currentTime);
//osciladors[1].type = 'triangle';
osciladors[1].type = tipo;
osciladors[2] = audioContext.createOscillator();
osciladors[2].frequency.setValueAtTime(132, audioContext.currentTime);
//osciladors[2].type = 'sine';
osciladors[2].type = tipo;
osciladors[3] = audioContext.createOscillator();
osciladors[3].frequency.setValueAtTime(88, audioContext.currentTime);
//osciladors[3].type = 'sawtooth';
osciladors[3].type = tipo;
osciladors[4] = audioContext.createOscillator();
osciladors[4].frequency.setValueAtTime(44, audioContext.currentTime);
osciladors[4].type = tipo;
var wave = audioContext.createPeriodicWave(real, imag);
osciladors[4].setPeriodicWave(wave);

var ganho = audioContext.createGain();
ganho.gain = 10;
//var slider = document.getElementById("slider");
//var output = document.getElementById("volume");
osciladors[0].connect(ganho);
osciladors[1].connect(ganho);
osciladors[2].connect(ganho);
osciladors[3].connect(ganho);
osciladors[4].connect(ganho);
for (var i = 0; i < osciladors.length; i++) {
  osciladors[i].start();
}

function playSound() {
  if(isPlaing){
    //oscilador.connect(biguad);
    ganho.disconnect(audioContext.destination);
    isPlaing = false;
  } else {
    //oscilador.disconnect(biguad);
    isPlaing = true;
    ganho.connect(audioContext.destination);
  }
}

function mudarFrequencia(valor) {

    for (var i =osciladors.length-1; i >= 0 ; i--) {
      osciladors[i].frequency.setValueAtTime(2*valor*(1+i)*44, audioContext.currentTime);
    }
    //output.innerHTML = volume*10;
}
function mudarVolume(volume) {
  if(volume>10.0){
    ganho.gain.value = volume/10;
    //output.innerHTML = volume/10;
  }
  if(volume<1.0){
    ganho.gain.value = volume*10;
    //output.innerHTML = volume*10;
  }
}
// ----------------------------------------------------------- Controles de Som


//initGUIControllers(myTracker);

</script>
</body>
</html>
