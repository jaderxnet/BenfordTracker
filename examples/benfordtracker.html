<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>tracking.js - color with video</title>

  <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
  <!--<link rel="stylesheet" href="assets/demo.css">
  <script src="../node_modules/dat.gui/build/dat.gui.min.js"></script>
  <script src="assets/stats.min.js"></script>
  <script src="assets/color_camera_gui.js"></script>-->
  <script src="../build/tracking-min.js"></script>
  <style>
  .demo-container {
    background-color: black;
  }

  video, canvas {
    position: absolute;
  }
  </style>
</style>
</head>
<body>
  <h2>Teste Algorítimo Benford</h2>
  <table width="1200" vertical-align="top">
    <tbody>
      <tr>
        <td>
          <div class="inputoutput">
            <div class="caption">
              <button type="button" id="buttonCameraVideo">Usar câmera</button>
              ou Selecione um vídeo. <input type="file" id="fileInputVideo" name="file" />
              <!--
              <input id="slider" oninput="mudarVolume(0)" type="range" min="0" max="10" value="0" step="0.01">
              Volume: <span id="volume"></span>
            -->
          </div>
        </div>
      </td>
    </tr>
    <tr>
      <td>
        <div class="demo-frame">
          <div class="demo-container">
            <video id="myVideo" width="800" height="500" preload autoplay loop muted></video>
            <canvas id="canvas" width="800" height="500"></canvas>
          </div>
        </div>
      </td>
      <td>
        <div id="triplo" style="width: 300px; height: 500px;"></div>
        <!--<div id="espacial" style="width: 300px; height: 500px;"></div>-->
        <!--<div id="temporal" style="width: 300px; height: 500px;"></div>-->
      </td>
    </tr>
  </tbody>
</table>

<script>
// Implementação de Benford Tracker -----------------------------------------------------------
// Quantidade de frames a serem contabilizados para os gradientes acumuldos
var quantidadeFramesAmostra = 10;
// Váriável que armazena a lista de valores padrões de benford
var valoresBenford = [9];
// Indice da fila que controla qual item da fila está sendo inserido para cada frame processado
var indiceFila = 0;
/* Variáveis que armazenam acorrencia de valores de primeiro dídigo para cada frame processado,
os acumulados temporais fundem dados de dois frames, por isso são menores que o espacial*/
var ocorrenciaEspacialPorFrame = [quantidadeFramesAmostra-1];
var ocorrenciaTriploPorFrame = [quantidadeFramesAmostra-1];
var ocorrenciaTemporalPorFrame = [quantidadeFramesAmostra-1];
// Variável armazena o frame anterior para comparar com o atual
var frameAnterior = null;
/*Variável identifica quando a fila de frames processados enche pela primeira vez, a partir
desse momento o algoritimo  deve substituir indices já existentes da fila*/
var  filaCheia = false;
// Variável para armazenar os resultados
var results = null;

//Inicização dos valores padrões de Benford
valoresBenford[0] = Math.log10(1.0+1.0/1.0);
valoresBenford[1] = Math.log10(1.0+1.0/2.0);
valoresBenford[2] = Math.log10(1.0+1.0/3.0);
valoresBenford[3] = Math.log10(1.0+1.0/4.0);
valoresBenford[4] = Math.log10(1.0+1.0/5.0);
valoresBenford[5] = Math.log10(1.0+1.0/6.0);
valoresBenford[6] = Math.log10(1.0+1.0/7.0);
valoresBenford[7] = Math.log10(1.0+1.0/8.0);
valoresBenford[8] = Math.log10(1.0+1.0/9.0);

// Classe principal do augorítimo de processamento de frame com base em Benford.
function BenfordTracker() {

/*Função principal do processamento. Essa função vai ser chamada para processar cada pixel, dessa forma
é necessário criar estratégias de otimização para que não acumulasse volume muito grande de dados.
Responsável por sobrescrever a função track da api tracking.js
permitindo receber uma matriz de pixels RGB em formato de array, a largura e autura da imgagem
representada na matriz.*/
  this.track = function(pixels, width, height) {
    /* usamos uma função interna da api para transformar a matriz de pixel RGB recebida em uma matriz cinza ]
    esse processo basicamente torna a matriz 3 vezes menor e diminui a complexidade dos calculos*/
    let gray = tracking.Image.grayscale(pixels, width, height, false);
    // Essa função zera a fila de ocorrencia permitindo o reuso das variáveis para otimizar o código
    zerarFilaOcorrencia();
    // Essa função processa o frame de pixels em escala de cinza e arrmazena nas variáveis da fila de ocorrencias
    processarFrame(gray, width, height);
    /* Essa função calcula a ocorrencia acumulada e outros dados de cada numero na fila de ocorrencia e armzena
    tudo em um mapa de resultados  */
    results = calcularTotalOcorrencia();

    //Essa é uma chamada da API que envia os resultados para o métodos que estão ouvindo, no caso a API de exibição do gráfico do Google
    this.emit('track', {
      data: results
    });
  }

// Essa função zera a fila de ocorrencia permitindo o reuso das variáveis para otimizar o código
  function zerarFilaOcorrencia(){
    //Percorre a fila de ocorrencia
    for(let x = 0; x < quantidadeFramesAmostra-1; ++x) {
      //Inicializa um array para cada numero de 1 a 9
      ocorrenciaTriploPorFrame[x] = [9];
      ocorrenciaTemporalPorFrame[x] = [9];
      ocorrenciaEspacialPorFrame[x] = [9];
      //Inicializa todas as ocorrencias com 0.0
      for(let y = 0; y < quantidadeFramesAmostra; ++y) {
        ocorrenciaEspacialPorFrame[x][y] = 0.0;
        ocorrenciaTemporalPorFrame[x][y] = 0.0;
        ocorrenciaTriploPorFrame[x][y] = 0.0;
      }
    }
  };


  function calcularOcorrenciaGradiente(gradiente){
    //Essa variavel armazena a ocorrencia do primeiro dígido na análise pixel a pixel
    let contaOcorrenciaNumeroPrimeiroDigito = 0 ;
    /*Com  o valor do gradiente temporal vamos contar as ocorrencias caso elas tenham valores relevante
    Elas podem ter entre 0 e 255 correspondente ao tom de cinza do gradiente correspondente
    Queremos contar aqui a quantidade de vezes que os dígitos de 1 a 9 se repetem na primeira posição do gradiente de cada pixel
    a iniciar pelo gradiente espacial*/
      //Se o gradiente for maior que 100 estará entre 101 e 255 logo o digito poderá ser 1 ou 2
      if(gradiente >= 100) {
        /*Caso o gradiente seja maior que 99 é extraida a parte menor que 100 e dividida por 100 para que de valor 1 ou 2 */
        contaOcorrenciaNumeroPrimeiroDigito = (gradiente-(gradiente%100))/100;
          //Se o gradiente for maior que 9 e menor que 101 estará entre 11 e 100 logo o digito poderá ser 1 e 9
      } else if (gradiente >= 10) {
        /*Caso o gradiente seja maior que 9 é extraida a parte menor que 10 e dividida por 10 para obter o primeiro dígito entre 1 e 9 */
        contaOcorrenciaNumeroPrimeiroDigito = (gradiente-(gradiente%10))/10;
      } else {
        /*Caso o gradiente seja menor que 10 será usada a operação MOD para retornar o resto da divisão por 1 para evitar
        um comportamento inesperado do javascript e garantir que o valo fique entre 1 e 9 */
        contaOcorrenciaNumeroPrimeiroDigito = (gradiente-gradiente%1);
      }
      /*A ocorrencia é retornada */
    return contaOcorrenciaNumeroPrimeiroDigito;
  };

/**
// Essa função processa o frame de pixels em escala de cinza e arrmazena nas variáveis da fila de ocorrencias
TODO:Criar classe ProcessadorFrame posteriormente*/
  function processarFrame( frame, width, height ) {
    //Inicializa uma variável para calcular cada gradiente
    let gradienteEspacial = 0;
    let gradienteTemporal = 0;
    let gradienteTriplo = 0;

    /* Para processar o primeiro frame é necessário existir frame anterior pois as análises temporais usam frame frameAnterior,
    portanto não procesa o primeiro frame, apenas a partir do segundo
    TODO Verificar se o não processamento do gradiente temporal do primeiro frame prejudica o algorítimo, até onde olhei não
    pois no código original também se pulava o primeiro frame*/
    if(frame && frameAnterior){
      /*Para calcular os gradientes fazemos uso de alguns cálculos que foram divididos em partes aqui para que os valores fossem
      reusados. no caso dos qaudrado temporal e espacial são usados para armazenar uma potencia de 2*/
      let quadradoTemporal = 0;
      let quadradoEspacialHorizontal = 0;
      let quadradoEspacialVertical = 0;
      //Essa variavel armazena a ocorrencia do primeiro dígido na análise pixel a pixel

      /*Usamos o index para percorrer todos os pixels da imagem exceto o primeiro e a última coluna por conta do gradiente espacial que usa o
      primeiro pixel como peixel anterior e não tem com quem comparar a última coluna
      TODO Vericicar se realmente não se deve percorrer a última colua, apesar de estar igual ao algoritimo original*/
      for (var index = 1; index < height*width-width; ++index) {
        //Para calcular o gradiente temporal subitraimos o frame anterior do frame atual
        gradienteTemporal = frame[index] - frameAnterior[index];
        //Para calcular o gradiente espacial primeiro tenho que calcular o gradiente espacial no eixo horizontal e vertical
        //Pra calcular o gradiente espacial horizontal eu faço a difrença entre o pixel atual e o próximo
        let gradienteEspacialHorizontal = frame[index+1] - frame[index];
        //Pra calcular o gradiente espacial vertical eu faço a difrença entre o pixel atual e o equivalente na próxima coluna
        let gradienteEspacialVertical = frame[index+width] - frame[index];
        //É necessário calcular o quadrdo espacial horizontal e vertical para usar no cálculo do gradiente espacial e triplo
        quadradoEspacialHorizontal = Math.pow(gradienteEspacialHorizontal, 2);
        quadradoEspacialVertical = Math.pow(gradienteEspacialVertical, 2);
        //O gradiente espacial é obtido calculando a raiz quadrada da soma do quadrado espacial vertical e horizontal
        gradienteEspacial = Math.sqrt( quadradoEspacialHorizontal + quadradoEspacialVertical);
        //Para obter o gradiente Triplo é necessário calcular o quadrado do gradiente temporal
        quadradoTemporal = Math.pow(gradienteTemporal, 2);
        //O gradiente Tripo é obtido calculando a raiz quadrada da soma do quadrado temporal, espacial vertical e horizontal
        gradienteTriplo = Math.sqrt( quadradoEspacialHorizontal + quadradoEspacialVertical + quadradoTemporal);


        /*Com  o valor do gradiente temporal vamos contar as ocorrencias caso elas tenham valores relevante
        Elas podem ter entre 0 e 255 correspondente ao tom de cinza do gradiente correspondente
        Queremos contar aqui a quantidade de vezes que os dígitos de 1 a 9 se repetem na primeira posição do gradiente de cada pixel
        a iniciar pelo gradiente espacial*/
        //se a norma espacial for significativa conta o primeiro digito encontrado
        if (gradienteEspacial > 0.001) {
          /*As ocorrencias  são armazenadas no contador de acordo com o primeiro digito do valor do pixel do gradiente no indice
          atual da fila que está sendo atualizado crescenta +1 na ocorrencia do número no frame */
          ocorrenciaEspacialPorFrame[indiceFila][calcularOcorrenciaGradiente(gradienteEspacial)-1]++;
        }

        if (gradienteTemporal > 0.001) {//se a norma espacial for significativa
          /*As ocorrencias  são armazenadas no contador de acordo com o primeiro digito do valor do pixel do gradiente no indice
          atual da fila que está sendo atualizado crescenta +1 na ocorrencia do número no frame */
          ocorrenciaTemporalPorFrame[indiceFila][calcularOcorrenciaGradiente(gradienteTemporal)-1]++;
        }

        if (gradienteTriplo > 0.001) {//se a norma espacial for significativa
          /*As ocorrencias  são armazenadas no contador de acordo com o primeiro digito do valor do pixel do gradiente no indice
          atual da fila que está sendo atualizado crescenta +1 na ocorrencia do número no frame */
          ocorrenciaTriploPorFrame[indiceFila][calcularOcorrenciaGradiente(gradienteTriplo)-1]++;
        }
      }
      //Se a fila não estiver cheia e o indice da fila chegar ao final marque a fila como cheia, isso define quando começar calcular valores
      if(!filaCheia && (indiceFila >= quantidadeFramesAmostra-2)){
        filaCheia = true;
      }
    }
    //Atualiza o indice da fila
    indiceFila++;
    //Quando o indice da fila chega ao final reinicia o indice para manter a fila circular
    indiceFila = indiceFila%(quantidadeFramesAmostra-1);
    //Atualiza o frame anterior
    frameAnterior = frame;
    frame = null;
  };

//Inicializamos as variáveis globais que serão usadas para exibir os valores principais e os gráficos gerais
  diferencaTripla = 0.0;
  diferencaEspacial = 0.0;
  diferencaTemporal = 0.0;

/*Este método calcula a ococrrência total dos valores e outras estatísticas sobre os pixels analisados */
  function calcularTotalOcorrencia(){
    //Só começa a fazer os calculos quando a fila está cheia e portanto foram processados frames mínimos
    if(filaCheia){
      //Variávelresponsável por armazenar no contexto do método os valores acumulados;
      let acumuladoTriplo = 0;
      let acumuladoEspacial = 0;
      let acumuladoTemporal = 0;
      let acumuladoTriploPorNumero = [9];
      let acumuladoEspacialPorNumero = [9];
      let acumuladoTemporalPorNumero = [9];
      diferencaTripla = 0.0;
      diferencaEspacial = 0.0;
      diferencaTemporal = 0.0;

      /* Percorre o a fila usando a variavel indice Frame para ir do início ao fim da fila */
      for(let indiceframe = 0; indiceframe < quantidadeFramesAmostra-1; indiceframe++) {
        /* Para cada indice da fila percorre os valores dos indices de digitos acumulados
        usando a variavel indice Digito para ir do indice 0 ao 8 que corresponde aos dígitos 1 ao 9 */
        for(let indiceDigito = 0; indiceDigito < 9; ++indiceDigito) {
          //Verifica se existe valor válido na ocorrência armazenada para evitar erro de variável nula no javascript
          if(ocorrenciaEspacialPorFrame[indiceframe][indiceDigito]){
            //Acumula valor da ocorrencia espacial para todos os  digitos de otodos os frames
            acumuladoEspacial += ocorrenciaEspacialPorFrame[indiceframe][indiceDigito];
            //Acumula valor da ocorrencia espacial para cada  digito em todos os frames
            acumuladoEspacialPorNumero[indiceDigito] += ocorrenciaEspacialPorFrame[indiceframe][indiceDigito];
          }
          //Verifica se existe valor válido na ocorrência armazenada para evitar erro de variável nula no javascript
          if(ocorrenciaTemporalPorFrame[indiceframe][indiceDigito]){
            //Acumula valor da ocorrencia temporal para todos os  digitos de otodos os frames
            acumuladoTemporal += ocorrenciaTemporalPorFrame[indiceframe][indiceDigito];
            //Acumula valor da ocorrencia temporal para cada  digito em todos os frames
            acumuladoTemporalPorNumero[indiceDigito] += ocorrenciaTemporalPorFrame[indiceframe][indiceDigito];
          }
          //Verifica se existe valor válido na ocorrência armazenada para evitar erro de variável nula no javascript
          if(ocorrenciaTriploPorFrame[indiceframe][indiceDigito]){
            //Acumula valor da ocorrencia espacial para todos os  digitos de otodos os frames
            acumuladoTriplo += ocorrenciaTriploPorFrame[indiceframe][indiceDigito];
            //Acumula valor da ocorrencia espacial para cada  digito em todos os frames
            acumuladoTriploPorNumero[indiceDigito] += ocorrenciaTriploPorFrame[indiceframe][indiceDigito];
          }
        }
      }

      // Percorre os nove níveis para calcular a diferença triplo
      for(let nivel = 0; nivel < 9; nivel++) {
        //Verifica se existe valor válido no acumulado para evitar erro de variável nula no javascript
        if (acumuladoTriploPorNumero[nivel]){
            //Verofica se acumulado por numero dividido pelo somatório total subtraido o valor esperado de Benford para esse dígito é positivo
            if (((acumuladoTriploPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel]) > 0) {
              //calcula a diferença Tripla caso ela seja positiva
              diferencaTripla += (acumuladoTriploPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel];
            } else {
              //calcula a diferença Tripla caso ela seja negativa
              diferencaTripla -= (acumuladoTriploPorNumero[nivel]/acumuladoTriplo)-valoresBenford[nivel];
            }
        }
      }
      //TODO Não sei o motivo de dividir a diferença tripla por dois, fiz isso pois estava no projeto horiginal
      diferencaTripla /= 2;
      //TODO Aqui subtrai de 1 o valor da diferença Tripla o que daria a porcentagem de conformidade, mas não tenho certeza que está no local correto
      diferencaTripla = 1 - diferencaTripla;
      // Percorre os nove níveis para calcular a diferença Espacial
      for(let nivel = 0; nivel < 9; nivel++) {
          //Verifica se existe valor válido no acumulado para evitar erro de variável nula no javascript
          if (acumuladoEspacialPorNumero[nivel]){
            //Verofica se acumulado por numero dividido pelo somatório total subtraido o valor esperado de Benford para esse dígito é positivo
            if (((acumuladoEspacialPorNumero[nivel]/acumuladoEspacial)-valoresBenford[nivel]) > 0) {
              //calcula a diferença Espacial caso ela seja positiva
              diferencaEspacial += (acumuladoEspacialPorNumero[nivel]/acumuladoEspacial)-valoresBenford[nivel];
            } else {
              //calcula a diferença Espacial caso ela seja negativa
              diferencaEspacial -= (acumuladoEspacialPorNumero[nivel]/acumuladoEspacial)-valoresBenford[nivel];
            }
          }
      }
      //TODO Não sei o motivo de dividir a diferença tripla por dois, fiz isso pois estava no projeto horiginal
      diferencaEspacial /= 2;
      //TODO Aqui subtrai de 1 o valor da diferença Tripla o que daria a porcentagem de conformidade, mas não tenho certeza que está no local correto
      diferencaEspacial = 1 - diferencaEspacial;
      // Percorre os nove níveis para calcular a diferença Temporal
      for(let nivel = 0; nivel < 9; nivel++) {
          //Verifica se existe valor válido no acumulado para evitar erro de variável nula no javascript
          if (acumuladoTemporalPorNumero[nivel]){
            //Verofica se acumulado por numero dividido pelo somatório total subtraido o valor esperado de Benford para esse dígito é positivo
            if (((acumuladoTemporalPorNumero[nivel]/acumuladoTemporal)-valoresBenford[nivel]) > 0) {
              //calcula a diferença Temporal caso ela seja positiva
              diferencaTemporal += (acumuladoTemporalPorNumero[nivel]/acumuladoTemporal)-valoresBenford[nivel];
            } else {
              //calcula a diferença Temporal caso ela seja negativa
              diferencaTemporal -= (acumuladoTemporalPorNumero[nivel]/acumuladoTemporal)-valoresBenford[nivel];
            }
          }
      }
      //TODO Não sei o motivo de dividir a diferença tripla por dois, fiz isso pois estava no projeto horiginal
      diferencaTemporal /= 2;
      //TODO Aqui subtrai de 1 o valor da diferença Tripla o que daria a porcentagem de conformidade, mas não tenho certeza que está no local correto
      diferencaTemporal = 1 - diferencaTemporal;

      //Armazena vários dados em um mapa de ocorrências
      let mapaOcorrencia = new Map();
      mapaOcorrencia.set("direfencaEspacial", diferencaEspacial.toFixed(2));
      mapaOcorrencia.set("diferencaTemporal", diferencaTemporal.toFixed(2));
      mapaOcorrencia.set("diferencaTriplo", diferencaTripla.toFixed(2));
      mapaOcorrencia.set("espacialPorFrame", ocorrenciaEspacialPorFrame);
      mapaOcorrencia.set("temporalPorFrame", ocorrenciaTemporalPorFrame);
      mapaOcorrencia.set("triploPorFrame", ocorrenciaTriploPorFrame);
      mapaOcorrencia.set("acumuladoEspacial", acumuladoEspacial);
      mapaOcorrencia.set("acumuladotemporal", acumuladoTemporal);
      mapaOcorrencia.set("acumuladotriplo", acumuladoTriplo);
      mapaOcorrencia.set("acumuladoEspacialPorNumero", acumuladoEspacialPorNumero);
      mapaOcorrencia.set("acumuladotemporalPorNumero", acumuladoTemporalPorNumero);
      mapaOcorrencia.set("acumuladotriploPorNumero", acumuladoTriploPorNumero);
      return mapaOcorrencia;
    }
  }

}


// Carrega API do Google para visualização de graficos
google.charts.load('current', {'packages':['bar']});
// Seleciona qual a função de retorno quando a API de visualização do Google for chamada
google.charts.setOnLoadCallback(drawStuff);
// O retorno cria o grafico e popula a tabela de dados,
// É necessário instanciar o grafico e popular os dados na configuração do gráfico em options do google chart
var chart = null;
var data = null;

/* Função que carrega os dados no gráfico após o retorno da API do Google
TODO Colocar isso em um work para quan a atualização seja instantânea e não dependa de atualização da tela*/
function loadDataChart(){
  //Variável para armazenar resultado
  let resultado =  0;
  //Avalia se há resultados no retorno da API Tracker
  if(results){
    //Copia o resultado que será usado para gerar o gráfico
    resultado = results.get("diferencaTriplo");
    //Normaliza o resultado para a escala de 100%
    resultado *= 100;
  }

  //Verifica se existe configuração valida de dados para o gráfico
  if(data){
    //Verifica se há informações anteriores na tabela
    if(data.getNumberOfRows()>0){
      //Remove as linhas atuais para atualizar o gráfico
      data.removeRows(0,1);
    }
    //Adiciona uma nova linha com os dados novos
    data.addRow([resultado,resultado]);
  } else {
    //Caso não haja dados previamente configurados cria as colunas necessárias
    data = new google.visualization.DataTable();
    data.addColumn('number', 'Difereça Tripla');
    data.addColumn('number', 'Difereça Tripla');
  }
}

//Função Responsável por desenhar o gráfico
function drawStuff() {
  // Criar a tabela de dados
  loadDataChart();
  // Configurar as opções de gráfico
  var options = {
    title: 'Gradiente Triplo de Benford',
    width: 300,
    legend: { position: 'none' },
    chart: { title: 'Gradiente Triplo de Benford',
    subtitle: 'Ocorrencia primeiro dígito por número' },
    bars: 'vertical', // Required for Material Bar Charts.
    axes: {
      x: {
        0: { side: 'down', label: 'Números'} // Top x-axis.
      },
      y: {
        0: { side: 'left', label: 'Porcentágem'} // Top x-axis.
      }
    },
    bar: { groupWidth: "90%" }
  };
  // Instanciar o gráfico no elemento da interface
  chart = new google.charts.Bar(document.getElementById('triplo'));
  //Desenhar gráfico de acordo com dados e opções
  chart.draw(data, options);
};

//Função que atualiza o gráfico a cada 1 segundo.
//TODO retirar isso quando implementar o worder
window.setInterval('drawStuff()', 1000);
//Implementação da Herança de BenfordTracker em relação a Traker da API tracking.js
tracking.inherits(BenfordTracker, tracking.Tracker);
//Instanciando o construtor de Benford Trafcker
BenfordTracker.prototype.constructor = BenfordTracker;

// variavel para armazenar o elemento canvas
var canvas = document.getElementById('canvas');
// Variável para armazenar  o contexto 2D
var context = canvas.getContext('2d');
// Instancia da classe de Benford
var myTracker = new BenfordTracker();

// Chamada da função principal que atualiza os dados do BenfordTracker pela API Tracking
myTracker.on('track', function(event){
  //Preparação do canvas para ser desenhado e receber texto
  context.clearRect(0, 0, canvas.width, canvas.height);
  context.strokeStyle = "#000";
  context.font = '10px Helvetica';
  context.fillStyle = "#000"

  //Verifica se existe dados válidos no evento recebido
  if(event.data){

    //Muda frequncia do som de acordo com dados recebidos
    mudarFrequencia(event.data.get("diferencaTriplo"));
    //Imprime no canvas texto com dados recebidos
    context.fillText("Espacial: " + event.data.get("direfencaEspacial"), 0 + 5, 10 + 22);
    context.fillText("Temporal: " + event.data.get("diferencaTemporal"), 0 + 5, 20 + 22);
    context.fillText("Triplo: " + event.data.get("diferencaTriplo"), 0 + 5, 30 + 22);
  }
});

// Controes de Entrada --------------------------------------------------------
//Exibir e processar o video da câmera  function capturaVideoWebCam
let inputElementVideo1 = document.getElementById('buttonCameraVideo');
// A partir do click de um botão o elemento inputElementVideo1 lança um evento
inputElementVideo1.addEventListener('click', (e) => {
  //O evento chamado dá início do processamento do imágens a partir da Web Cam
  tracking.track('#myVideo', myTracker, { camera: true });
  //inicia o monitoramento do som
  playSound();
//Fim do comando de disparo do evento
}, false);

//Exibir e processar video do armazenamento local a partir de janela de acesso a arquivos
let inputElementVideo2 = document.getElementById('fileInputVideo');
// A partir da seleção de um arquivo como entrada para inputElementVideo2 lança um evento
inputElementVideo2.addEventListener('change', (e) => {
  // Elemento de vídeo é colocado em uma variavel
  let videoTag = document.getElementById('myVideo');
  //O evento chamado dá início do processamento do arquivo de vídeo selecionado
  videoTag.src=URL.createObjectURL(e.target.files[0]);
  // O vídeo é reproduzido no canvas
  videoTag.play();
  //O evento chamado dá início do processamento do imágens a partir da arquivo selecionado
  tracking.track('#myVideo', myTracker);
  //inicia o monitoramento do som
  playSound();
  //Fim do comando de disparo do evento
}, false);
// -------------------------------------------------------- Controes de Entrada

// Controles de Som -----------------------------------------------------------
// É criado um contexto de audio de acordo com a tecnologia disponível no Browser
var audioContext = new (window.AudioContext || window.webkitAudioContext)();
//Controle de play do audio
var isPlaing = false;
//Elementos criados para ser a semente do som criado
var real = new Float32Array(2);
var imag = new Float32Array(2);

//A semente do som gerado é o valor 1 e 0, uma base binária
real[0] = 0;
imag[0] = 0;
real[1] = 1;
imag[1] = 0;

//Seta o ocilador para o tipo sino
let tipo = 'sine';
//cria um array de osciladores, essa é melhor mandeira de o som ficar agradável
var osciladors = [5]
// Cria e configura cada oscilador com uma frequencia diferente podendo ter também tipos diferentes
osciladors[0] = audioContext.createOscillator();
osciladors[0].frequency.setValueAtTime(220, audioContext.currentTime);
//osciladors[0].type = 'square';
osciladors[0].type = tipo;
osciladors[1] = audioContext.createOscillator();
osciladors[1].frequency.setValueAtTime(176, audioContext.currentTime);
//osciladors[1].type = 'triangle';
osciladors[1].type = tipo;
osciladors[2] = audioContext.createOscillator();
osciladors[2].frequency.setValueAtTime(132, audioContext.currentTime);
//osciladors[2].type = 'sine';
osciladors[2].type = tipo;
osciladors[3] = audioContext.createOscillator();
osciladors[3].frequency.setValueAtTime(88, audioContext.currentTime);
//osciladors[3].type = 'sawtooth';
osciladors[3].type = tipo;
osciladors[4] = audioContext.createOscillator();
osciladors[4].frequency.setValueAtTime(44, audioContext.currentTime);
osciladors[4].type = tipo;

//Cria a onda a partir dos valores sementes
var wave = audioContext.createPeriodicWave(real, imag);
//Usa a onda para definir o período da onda do último scilador
osciladors[4].setPeriodicWave(wave);

//Ganho determina o volume de saída do audio
var ganho = audioContext.createGain();
//O volume maximo é definido
ganho.gain = 10;
//Interconectamos os osciladores
osciladors[0].connect(ganho);
osciladors[1].connect(ganho);
osciladors[2].connect(ganho);
osciladors[3].connect(ganho);
osciladors[4].connect(ganho);
//Inicializamos todos os osciladores
for (var i = 0; i < osciladors.length; i++) {
  osciladors[i].start();
}

//Função que controla o som conectando ou disconectando o ganho ao contexto
function playSound() {
  if(isPlaing){
    //oscilador.connect(biguad);
    ganho.disconnect(audioContext.destination);
    isPlaing = false;
  } else {
    //oscilador.disconnect(biguad);
    isPlaing = true;
    ganho.connect(audioContext.destination);
  }
}

// Função que muda a frequencia de acordo com o valor recebido
function mudarFrequencia(valor) {
    for (var i =osciladors.length-1; i >= 0 ; i--) {
      osciladors[i].frequency.setValueAtTime(2*valor*(1+i)*44, audioContext.currentTime);
    }
    //output.innerHTML = volume*10;
}

//Função que muda o ganho de acordo com valor recebido
function mudarVolume(volume) {
  if(volume>10.0){
    ganho.gain.value = volume/10;
    //output.innerHTML = volume/10;
  }
  if(volume<1.0){
    ganho.gain.value = volume*10;
    //output.innerHTML = volume*10;
  }
}
// ----------------------------------------------------------- Controles de Som

//TODO Função que incializa controles da API trancking que ainda não está sendo usado
//initGUIControllers(myTracker);

</script>
</body>
</html>
